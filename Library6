--[[
    Mod Menu Library v2.1
    Полностью исправленная и оптимизированная библиотека
    Автор: Фатима ♥️
    Дата: 2024
]]--

local ModMenu = {}
ModMenu.__index = ModMenu

-- Сервисы
local Players = game:GetService("Players")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")

-- Константы
local PLAYER = Players.LocalPlayer
local MOUSE = PLAYER:GetMouse()
local IS_MOBILE = UserInputService.TouchEnabled
local IS_CONSOLE = UserInputService.GamepadEnabled
local IS_PC = not IS_MOBILE and not IS_CONSOLE

-- Настройки по умолчанию
local DEFAULT_SETTINGS = {
    Menu = {
        Accent = Color3.fromRGB(100, 150, 255),
        Background = Color3.fromRGB(20, 20, 25),
        Text = Color3.fromRGB(240, 240, 245),
        Transparency = 0.05,
        Size = IS_MOBILE and 0.8 or 1.0
    },
    ESP = {
        Enabled = false,
        Box = true,
        Tracer = true,
        Health = true,
        Names = true,
        Distance = true,
        MaxDistance = 500,
        TeamCheck = true,
        Color = Color3.fromRGB(255, 50, 50)
    },
    Aimbot = {
        Enabled = false,
        Mode = "Legit",
        Bone = "Head",
        FOV = 100,
        Smoothness = 0.5,
        TeamCheck = true,
        VisibleCheck = true
    },
    Visual = {
        Fullbright = false,
        Chams = false,
        Ambient = Color3.new(0.5, 0.5, 0.5),
        Brightness = 1
    },
    Player = {
        GodMode = false,
        Speed = 16,
        JumpPower = 50,
        NoClip = false,
        Fly = false
    }
}

-- Вспомогательные функции
local function Create(instanceType, properties)
    local obj = Instance.new(instanceType)
    for prop, value in pairs(properties) do
        obj[prop] = value
    end
    return obj
end

local function Tween(obj, props, duration, style)
    local tweenInfo = TweenInfo.new(duration or 0.2, style or Enum.EasingStyle.Quad)
    local tween = TweenService:Create(obj, tweenInfo, props)
    tween:Play()
    return tween
end

local function Round(num, decimal)
    local mult = 10^(decimal or 2)
    return math.floor(num * mult + 0.5) / mult
end

local function DeepCopy(original)
    local copy = {}
    for k, v in pairs(original) do
        if type(v) == "table" then
            copy[k] = DeepCopy(v)
        else
            copy[k] = v
        end
    end
    return copy
end

-- Основной класс
function ModMenu.new(menuName)
    local self = setmetatable({}, ModMenu)
    
    self.MenuName = menuName or "ModMenu"
    self.Version = "2.1"
    self.GUI = nil
    self.Settings = DeepCopy(DEFAULT_SETTINGS)
    self.Connections = {}
    self.Elements = {}
    self.ESP = {Objects = {}}
    self.Aimbot = {Target = nil}
    self.Active = false
    self.Notifications = {}
    self.FloatingTexts = {}
    self.MenuOpen = false
    
    self.MenuID = "Menu_" .. HttpService:GenerateGUID(false):sub(1, 8)
    
    self:CleanupOldMenus()
    self:Initialize()
    
    return self
end

-- Очистка старых меню
function ModMenu:CleanupOldMenus()
    local menus = CoreGui:FindFirstChild("ModMenus")
    if menus then
        for _, menu in ipairs(menus:GetChildren()) do
            if menu.Name:find("Menu_") then
                menu:Destroy()
            end
        end
    end
end

-- Инициализация
function ModMenu:Initialize()
    -- Создаем контейнер
    local container = Create("Folder", {
        Name = "ModMenus",
        Parent = CoreGui
    })
    
    -- Создаем ScreenGui
    self.GUI = Create("ScreenGui", {
        Name = self.MenuID,
        Parent = container,
        DisplayOrder = 9999,
        ResetOnSpawn = false,
        ZIndexBehavior = Enum.ZIndexBehavior.Global
    })
    
    -- Создаем главную кнопку
    self:CreateMainButton()
    
    -- Создаем плавающие надписи (скрытые по умолчанию)
    self:CreateFloatingTexts()
    
    -- Создаем основное меню
    self:CreateMainMenu()
    
    -- Создаем окно настроек
    self:CreateSettingsWindow()
    
    -- Инициализируем системы
    self:InitSystems()
    
    self.Active = true
    self:Notify("Меню загружено! v" .. self.Version)
end

-- Создание главной кнопки
function ModMenu:CreateMainButton()
    self.MainButton = Create("TextButton", {
        Name = "MainButton",
        Parent = self.GUI,
        Text = "≡",
        Font = Enum.Font.GothamBold,
        TextSize = 28,
        TextColor3 = Color3.new(1, 1, 1),
        BackgroundColor3 = Color3.fromRGB(40, 40, 50),
        BorderSizePixel = 0,
        Size = UDim2.new(0, 50, 0, 50),
        Position = UDim2.new(0, 20, 0.5, -25),
        ZIndex = 1000
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = self.MainButton
    })
    
    -- Добавляем интерактивность
    self:MakeDraggable(self.MainButton)
    
    self.MainButton.MouseButton1Click:Connect(function()
        self:ToggleMenu()
    end)
    
    self.MainButton.TouchTap:Connect(function()
        self:ToggleMenu()
    end)
    
    -- Эффекты при наведении
    self.MainButton.MouseEnter:Connect(function()
        Tween(self.MainButton, {BackgroundColor3 = Color3.fromRGB(60, 60, 70)})
    end)
    
    self.MainButton.MouseLeave:Connect(function()
        Tween(self.MainButton, {BackgroundColor3 = Color3.fromRGB(40, 40, 50)})
    end)
end

-- Создание плавающих надписей "Фатима ♥️"
function ModMenu:CreateFloatingTexts()
    local text = "Фатима ♥️"
    local colors = {
        Color3.fromRGB(255, 100, 150),  -- Розовый
        Color3.fromRGB(100, 200, 255),  -- Голубой
        Color3.fromRGB(150, 255, 150),  -- Зеленый
        Color3.fromRGB(255, 255, 100),  -- Желтый
        Color3.fromRGB(255, 150, 100)   -- Оранжевый
    }
    
    for i = 1, 5 do
        local floatText = Create("TextLabel", {
            Name = "FloatText_" .. i,
            Parent = self.GUI,
            Text = text,
            Font = Enum.Font.GothamBold,
            TextSize = 24 + math.random(-4, 4),
            TextColor3 = colors[i],
            TextTransparency = 0.3,
            BackgroundTransparency = 1,
            Size = UDim2.new(0, 120, 0, 40),
            Position = UDim2.new(math.random() * 0.8, 0, math.random() * 0.8, 0),
            ZIndex = 900,
            Visible = false  -- По умолчанию скрыты
        })
        
        table.insert(self.FloatingTexts, floatText)
        
        -- Анимация плавания
        local thread = task.spawn(function()
            local startPos = floatText.Position
            local time = 0
            local speed = 0.3 + math.random() * 0.4
            local radius = 40 + math.random() * 60
            local offsetX = math.random() * 100
            local offsetY = math.random() * 100
            
            while floatText and floatText.Parent do
                if not self.MenuOpen then  -- Анимируем только когда меню закрыто
                    time += RunService.RenderStepped:Wait()
                    
                    local x = startPos.X.Offset + math.sin(time * speed + offsetX) * radius
                    local y = startPos.Y.Offset + math.cos(time * speed * 0.7 + offsetY) * radius * 0.6
                    
                    floatText.Position = UDim2.new(startPos.X.Scale, x, startPos.Y.Scale, y)
                    
                    -- Мерцание прозрачности
                    local transparency = 0.2 + math.sin(time * 1.5) * 0.3
                    floatText.TextTransparency = transparency
                else
                    task.wait(0.1)  -- Ждем когда меню откроется
                end
            end
        end)
        
        table.insert(self.Connections, {
            Disconnect = function()
                if thread then
                    task.cancel(thread)
                end
            end
        })
    end
end

-- Обновление видимости плавающих надписей
function ModMenu:UpdateFloatingTextsVisibility()
    for _, text in ipairs(self.FloatingTexts) do
        if text then
            text.Visible = not self.MenuOpen
        end
    end
end

-- Создание основного меню
function ModMenu:CreateMainMenu()
    self.MenuFrame = Create("Frame", {
        Name = "MenuFrame",
        Parent = self.GUI,
        BackgroundColor3 = self.Settings.Menu.Background,
        BackgroundTransparency = self.Settings.Menu.Transparency,
        BorderSizePixel = 0,
        Size = UDim2.new(0, 600, 0, 400),
        Position = UDim2.new(0.5, -300, 0.5, -200),
        Visible = false,
        ZIndex = 100
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(0, 12),
        Parent = self.MenuFrame
    })
    
    -- Title bar
    local titleBar = Create("Frame", {
        Name = "TitleBar",
        Parent = self.MenuFrame,
        BackgroundColor3 = Color3.fromRGB(30, 30, 40),
        BorderSizePixel = 0,
        Size = UDim2.new(1, 0, 0, 40),
        ZIndex = 101
    })
    
    local title = Create("TextLabel", {
        Name = "Title",
        Parent = titleBar,
        Text = self.MenuName .. " v" .. self.Version,
        Font = Enum.Font.GothamBold,
        TextSize = 18,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 200, 1, 0),
        Position = UDim2.new(0, 15, 0, 0),
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 102
    })
    
    local closeBtn = Create("TextButton", {
        Name = "CloseButton",
        Parent = titleBar,
        Text = "×",
        Font = Enum.Font.GothamBold,
        TextSize = 24,
        TextColor3 = Color3.fromRGB(255, 100, 100),
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 40, 1, 0),
        Position = UDim2.new(1, -40, 0, 0),
        ZIndex = 102
    })
    
    -- Делаем меню перетаскиваемым
    self:MakeDraggable(self.MenuFrame, titleBar)
    
    -- Кнопка настроек
    local settingsBtn = Create("TextButton", {
        Name = "SettingsButton",
        Parent = titleBar,
        Text = "⚙",
        Font = Enum.Font.GothamBold,
        TextSize = 18,
        TextColor3 = self.Settings.Menu.Accent,
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 40, 1, 0),
        Position = UDim2.new(1, -80, 0, 0),
        ZIndex = 102
    })
    
    -- Контейнер для контента
    local content = Create("Frame", {
        Name = "Content",
        Parent = self.MenuFrame,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 1, -40),
        Position = UDim2.new(0, 0, 0, 40),
        ZIndex = 101
    })
    
    -- Левая панель с табами
    self.LeftPanel = Create("ScrollingFrame", {
        Name = "LeftPanel",
        Parent = content,
        BackgroundColor3 = Color3.fromRGB(25, 25, 30),
        BackgroundTransparency = 0.1,
        BorderSizePixel = 0,
        Size = UDim2.new(0, 150, 1, 0),
        Position = UDim2.new(0, 0, 0, 0),
        CanvasSize = UDim2.new(0, 0, 0, 0),
        ScrollBarThickness = 3,
        ScrollBarImageColor3 = self.Settings.Menu.Accent,
        ZIndex = 102
    })
    
    local leftList = Create("UIListLayout", {
        Parent = self.LeftPanel,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 5)
    })
    
    leftList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        self.LeftPanel.CanvasSize = UDim2.new(0, 0, 0, leftList.AbsoluteContentSize.Y + 10)
    end)
    
    -- Правая панель с контентом
    self.RightPanel = Create("ScrollingFrame", {
        Name = "RightPanel",
        Parent = content,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -160, 1, 0),
        Position = UDim2.new(0, 160, 0, 0),
        CanvasSize = UDim2.new(0, 0, 0, 0),
        ScrollBarThickness = 3,
        ScrollBarImageColor3 = self.Settings.Menu.Accent,
        ZIndex = 101
    })
    
    local rightList = Create("UIListLayout", {
        Parent = self.RightPanel,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 10)
    })
    
    rightList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        self.RightPanel.CanvasSize = UDim2.new(0, 0, 0, rightList.AbsoluteContentSize.Y + 20)
    end)
    
    -- Обработчики событий
    closeBtn.MouseButton1Click:Connect(function()
        self:ToggleMenu()
    end)
    
    settingsBtn.MouseButton1Click:Connect(function()
        self:ToggleSettings()
    end)
    
    -- Размер для мобильных
    if IS_MOBILE then
        self.MenuFrame.Size = UDim2.new(0.9, 0, 0.8, 0)
        self.MenuFrame.Position = UDim2.new(0.05, 0, 0.1, 0)
    end
end

-- Добавление таба
function ModMenu:AddTab(name, icon)
    local tabButton = Create("TextButton", {
        Name = name .. "Tab",
        Parent = self.LeftPanel,
        Text = "   " .. icon .. " " .. name,
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Text,
        TextXAlignment = Enum.TextXAlignment.Left,
        BackgroundColor3 = Color3.fromRGB(40, 40, 50),
        BorderSizePixel = 0,
        Size = UDim2.new(1, -10, 0, 35),
        LayoutOrder = #self.LeftPanel:GetChildren(),
        AutoButtonColor = false
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(0, 6),
        Parent = tabButton
    })
    
    local contentFrame = Create("Frame", {
        Name = name .. "Content",
        Parent = self.RightPanel,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 0),
        LayoutOrder = #self.RightPanel:GetChildren(),
        Visible = false
    })
    
    local contentList = Create("UIListLayout", {
        Parent = contentFrame,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 10)
    })
    
    contentList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        contentFrame.Size = UDim2.new(1, 0, 0, contentList.AbsoluteContentSize.Y)
    end)
    
    -- Показываем первый таб
    if #self.LeftPanel:GetChildren() == 1 then
        tabButton.BackgroundColor3 = self.Settings.Menu.Accent
        contentFrame.Visible = true
        self.ActiveTab = name
    end
    
    tabButton.MouseButton1Click:Connect(function()
        self:SwitchTab(name, tabButton, contentFrame)
    end)
    
    return contentFrame
end

-- Переключение табов
function ModMenu:SwitchTab(tabName, tabButton, contentFrame)
    -- Сбрасываем цвет всех табов
    for _, child in ipairs(self.LeftPanel:GetChildren()) do
        if child:IsA("TextButton") then
            child.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
        end
    end
    
    -- Скрываем весь контент
    for _, child in ipairs(self.RightPanel:GetChildren()) do
        if child:IsA("Frame") then
            child.Visible = false
        end
    end
    
    -- Активируем выбранный таб
    tabButton.BackgroundColor3 = self.Settings.Menu.Accent
    contentFrame.Visible = true
    self.ActiveTab = tabName
end

-- Создание окна настроек
function ModMenu:CreateSettingsWindow()
    self.SettingsFrame = Create("Frame", {
        Name = "SettingsFrame",
        Parent = self.GUI,
        BackgroundColor3 = self.Settings.Menu.Background,
        BackgroundTransparency = self.Settings.Menu.Transparency,
        BorderSizePixel = 0,
        Size = UDim2.new(0, 700, 0, 500),
        Position = UDim2.new(0.5, -350, 0.5, -250),
        Visible = false,
        ZIndex = 200
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(0, 12),
        Parent = self.SettingsFrame
    })
    
    -- Title bar настроек
    local settingsTitleBar = Create("Frame", {
        Name = "SettingsTitleBar",
        Parent = self.SettingsFrame,
        BackgroundColor3 = Color3.fromRGB(30, 30, 40),
        BorderSizePixel = 0,
        Size = UDim2.new(1, 0, 0, 40),
        ZIndex = 201
    })
    
    local settingsTitle = Create("TextLabel", {
        Name = "SettingsTitle",
        Parent = settingsTitleBar,
        Text = "Настройки",
        Font = Enum.Font.GothamBold,
        TextSize = 18,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 200, 1, 0),
        Position = UDim2.new(0, 15, 0, 0),
        TextXAlignment = Enum.TextXAlignment.Left,
        ZIndex = 202
    })
    
    local settingsClose = Create("TextButton", {
        Name = "SettingsClose",
        Parent = settingsTitleBar,
        Text = "×",
        Font = Enum.Font.GothamBold,
        TextSize = 24,
        TextColor3 = Color3.fromRGB(255, 100, 100),
        BackgroundTransparency = 1,
        Size = UDim2.new(0, 40, 1, 0),
        Position = UDim2.new(1, -40, 0, 0),
        ZIndex = 202
    })
    
    -- Делаем окно настроек перетаскиваемым
    self:MakeDraggable(self.SettingsFrame, settingsTitleBar)
    
    -- Контент настроек
    local settingsContent = Create("ScrollingFrame", {
        Name = "SettingsContent",
        Parent = self.SettingsFrame,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 1, -40),
        Position = UDim2.new(0, 0, 0, 40),
        CanvasSize = UDim2.new(0, 0, 0, 0),
        ScrollBarThickness = 3,
        ScrollBarImageColor3 = self.Settings.Menu.Accent,
        ZIndex = 201
    })
    
    local settingsList = Create("UIListLayout", {
        Parent = settingsContent,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 15)
    })
    
    settingsList:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        settingsContent.CanvasSize = UDim2.new(0, 0, 0, settingsList.AbsoluteContentSize.Y + 20)
    end)
    
    -- Наполняем настройками (ИСПРАВЛЕНО: убрал AddColorPicker)
    self:CreateSettingsSections(settingsContent)
    
    -- Обработчик закрытия
    settingsClose.MouseButton1Click:Connect(function()
        self:ToggleSettings()
    end)
    
    -- Размер для мобильных
    if IS_MOBILE then
        self.SettingsFrame.Size = UDim2.new(0.95, 0, 0.9, 0)
        self.SettingsFrame.Position = UDim2.new(0.025, 0, 0.05, 0)
    end
end

-- Создание секций настроек (ИСПРАВЛЕНО)
function ModMenu:CreateSettingsSections(container)
    -- Цвета меню
    local colorsSection = self:CreateSection("Цвета меню", container)
    
    -- Используем ColorPicker (теперь он существует)
    self:ColorPicker(colorsSection, "Акцентный цвет", self.Settings.Menu.Accent, function(color)
        self.Settings.Menu.Accent = color
        self:UpdateColors()
    end)
    
    self:Slider(colorsSection, "Прозрачность", 0, 100, self.Settings.Menu.Transparency * 100, 1, function(value)
        self.Settings.Menu.Transparency = value / 100
        self:UpdateTransparency()
    end)
    
    -- Настройки ESP
    local espSection = self:CreateSection("Настройки ESP", container)
    
    self:Toggle(espSection, "Включить ESP", self.Settings.ESP.Enabled, function(value)
        self.Settings.ESP.Enabled = value
        self:UpdateESP()
    end)
    
    self:Toggle(espSection, "Рамки", self.Settings.ESP.Box, function(value)
        self.Settings.ESP.Box = value
    end)
    
    self:Toggle(espSection, "Линии", self.Settings.ESP.Tracer, function(value)
        self.Settings.ESP.Tracer = value
    end)
    
    self:Slider(espSection, "Макс. дистанция", 0, 1000, self.Settings.ESP.MaxDistance, 10, function(value)
        self.Settings.ESP.MaxDistance = value
    end)
    
    -- Настройки аимбота
    local aimbotSection = self:CreateSection("Настройки аимбота", container)
    
    self:Toggle(aimbotSection, "Включить аимбот", self.Settings.Aimbot.Enabled, function(value)
        self.Settings.Aimbot.Enabled = value
    end)
    
    self:Dropdown(aimbotSection, "Режим", {"Legit", "Silent", "Trigger"}, self.Settings.Aimbot.Mode, function(value)
        self.Settings.Aimbot.Mode = value
    end)
    
    self:Dropdown(aimbotSection, "Кость", {"Head", "Torso", "Random"}, self.Settings.Aimbot.Bone, function(value)
        self.Settings.Aimbot.Bone = value
    end)
    
    self:Slider(aimbotSection, "FOV", 0, 360, self.Settings.Aimbot.FOV, 5, function(value)
        self.Settings.Aimbot.FOV = value
    end)
    
    self:Slider(aimbotSection, "Плавность", 0, 1, self.Settings.Aimbot.Smoothness, 0.1, function(value)
        self.Settings.Aimbot.Smoothness = value
    end)
    
    -- Визуальные настройки
    local visualSection = self:CreateSection("Визуальные настройки", container)
    
    self:Toggle(visualSection, "Полное освещение", self.Settings.Visual.Fullbright, function(value)
        self.Settings.Visual.Fullbright = value
        self:UpdateFullbright()
    end)
    
    self:Toggle(visualSection, "Чамсы", self.Settings.Visual.Chams, function(value)
        self.Settings.Visual.Chams = value
    end)
    
    -- Настройки игрока
    local playerSection = self:CreateSection("Настройки игрока", container)
    
    self:Toggle(playerSection, "Бог-мод", self.Settings.Player.GodMode, function(value)
        self.Settings.Player.GodMode = value
    end)
    
    self:Toggle(playerSection, "Полёт", self.Settings.Player.Fly, function(value)
        self.Settings.Player.Fly = value
        self:ToggleFly(value)
    end)
    
    self:Toggle(playerSection, "NoClip", self.Settings.Player.NoClip, function(value)
        self.Settings.Player.NoClip = value
        self:ToggleNoClip(value)
    end)
    
    self:Slider(playerSection, "Скорость", 0, 100, self.Settings.Player.Speed, 1, function(value)
        self.Settings.Player.Speed = value
    end)
    
    self:Slider(playerSection, "Сила прыжка", 0, 200, self.Settings.Player.JumpPower, 5, function(value)
        self.Settings.Player.JumpPower = value
    end)
end

-- UI Компоненты (ИСПРАВЛЕННЫЕ)

function ModMenu:CreateSection(title, parent)
    local section = Create("Frame", {
        Name = title .. "Section",
        Parent = parent,
        BackgroundColor3 = Color3.fromRGB(30, 30, 35),
        BackgroundTransparency = 0.1,
        Size = UDim2.new(1, -20, 0, 0),
        LayoutOrder = #parent:GetChildren()
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(0, 8),
        Parent = section
    })
    
    local padding = Create("UIPadding", {
        Parent = section,
        PaddingLeft = UDim.new(0, 15),
        PaddingRight = UDim.new(0, 15),
        PaddingTop = UDim.new(0, 10),
        PaddingBottom = UDim.new(0, 10)
    })
    
    local titleLabel = Create("TextLabel", {
        Name = "Title",
        Parent = section,
        Text = title,
        Font = Enum.Font.GothamBold,
        TextSize = 16,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 25),
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    local list = Create("UIListLayout", {
        Parent = section,
        SortOrder = Enum.SortOrder.LayoutOrder,
        Padding = UDim.new(0, 8)
    })
    
    list:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        section.Size = UDim2.new(1, -20, 0, list.AbsoluteContentSize.Y + 35)
    end)
    
    return section
end

-- Кнопка
function ModMenu:Btn(parent, text, callback)
    local button = Create("TextButton", {
        Name = text .. "Btn",
        Parent = parent,
        Text = text,
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = Color3.new(1, 1, 1),
        BackgroundColor3 = self.Settings.Menu.Accent,
        BorderSizePixel = 0,
        Size = UDim2.new(1, 0, 0, 35),
        LayoutOrder = #parent:GetChildren(),
        AutoButtonColor = false
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(0, 6),
        Parent = button
    })
    
    -- Ripple эффект
    local function OnClick()
        self:RippleEffect(button)
        if callback then 
            local success, err = pcall(callback)
            if not success then
                self:Notify("Ошибка: " .. tostring(err), 3)
            end
        end
    end
    
    button.MouseButton1Click:Connect(OnClick)
    button.TouchTap:Connect(OnClick)
    
    -- Эффекты при наведении
    button.MouseEnter:Connect(function()
        Tween(button, {BackgroundColor3 = self:LightenColor(self.Settings.Menu.Accent, 20)})
    end)
    
    button.MouseLeave:Connect(function()
        Tween(button, {BackgroundColor3 = self.Settings.Menu.Accent})
    end)
    
    return button
end

-- Переключатель
function ModMenu:Toggle(parent, text, state, callback)
    local toggle = Create("Frame", {
        Name = text .. "Toggle",
        Parent = parent,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 30),
        LayoutOrder = #parent:GetChildren()
    })
    
    local label = Create("TextLabel", {
        Name = "Label",
        Parent = toggle,
        Text = text,
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(0.7, 0, 1, 0),
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    local switch = Create("Frame", {
        Name = "Switch",
        Parent = toggle,
        BackgroundColor3 = Color3.fromRGB(60, 60, 70),
        Size = UDim2.new(0, 50, 0, 25),
        Position = UDim2.new(1, -50, 0.5, -12.5)
    })
    
    local switchCorner = Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = switch
    })
    
    local dot = Create("Frame", {
        Name = "Dot",
        Parent = switch,
        BackgroundColor3 = Color3.new(1, 1, 1),
        Size = UDim2.new(0, 19, 0, 19),
        Position = UDim2.new(0, 3, 0.5, -9.5)
    })
    
    local dotCorner = Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = dot
    })
    
    -- Функция обновления состояния
    local function UpdateState(value)
        state = value
        if value then
            Tween(dot, {Position = UDim2.new(1, -22, 0.5, -9.5)})
            Tween(switch, {BackgroundColor3 = self.Settings.Menu.Accent})
        else
            Tween(dot, {Position = UDim2.new(0, 3, 0.5, -9.5)})
            Tween(switch, {BackgroundColor3 = Color3.fromRGB(60, 60, 70)})
        end
        if callback then 
            local success, err = pcall(callback, value)
            if not success then
                self:Notify("Ошибка: " .. tostring(err), 3)
            end
        end
    end
    
    -- Инициализация состояния
    UpdateState(state)
    
    -- Обработчики кликов
    local function ToggleState()
        UpdateState(not state)
    end
    
    local function SafeToggle()
        local success, err = pcall(ToggleState)
        if not success then
            self:Notify("Ошибка: " .. tostring(err), 3)
        end
    end
    
    switch.MouseButton1Click:Connect(SafeToggle)
    label.MouseButton1Click:Connect(SafeToggle)
    switch.TouchTap:Connect(SafeToggle)
    label.TouchTap:Connect(SafeToggle)
    
    return {
        Update = UpdateState,
        GetState = function() return state end
    }
end

-- Слайдер
function ModMenu:Slider(parent, text, min, max, value, step, callback)
    local slider = Create("Frame", {
        Name = text .. "Slider",
        Parent = parent,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 50),
        LayoutOrder = #parent:GetChildren()
    })
    
    local top = Create("Frame", {
        Name = "Top",
        Parent = slider,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 20)
    })
    
    local label = Create("TextLabel", {
        Name = "Label",
        Parent = top,
        Text = text,
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(0.7, 0, 1, 0),
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    local valueLabel = Create("TextLabel", {
        Name = "Value",
        Parent = top,
        Text = tostring(value),
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Accent,
        BackgroundTransparency = 1,
        Size = UDim2.new(0.3, 0, 1, 0),
        Position = UDim2.new(0.7, 0, 0, 0),
        TextXAlignment = Enum.TextXAlignment.Right
    })
    
    local track = Create("Frame", {
        Name = "Track",
        Parent = slider,
        BackgroundColor3 = Color3.fromRGB(60, 60, 70),
        Size = UDim2.new(1, 0, 0, 6),
        Position = UDim2.new(0, 0, 1, -16)
    })
    
    local trackCorner = Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = track
    })
    
    local fill = Create("Frame", {
        Name = "Fill",
        Parent = track,
        BackgroundColor3 = self.Settings.Menu.Accent,
        Size = UDim2.new((value - min) / (max - min), 0, 1, 0)
    })
    
    local fillCorner = Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = fill
    })
    
    local thumb = Create("Frame", {
        Name = "Thumb",
        Parent = track,
        BackgroundColor3 = Color3.new(1, 1, 1),
        Size = UDim2.new(0, 16, 0, 16),
        Position = UDim2.new((value - min) / (max - min), -8, 0.5, -8)
    })
    
    local thumbCorner = Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = thumb
    })
    
    -- Функция обновления значения
    local function UpdateValue(newValue)
        newValue = math.clamp(newValue, min, max)
        if step then
            newValue = math.floor(newValue / step + 0.5) * step
        end
        
        value = newValue
        valueLabel.Text = tostring(Round(value, 2))
        
        local percent = (value - min) / (max - min)
        fill.Size = UDim2.new(percent, 0, 1, 0)
        thumb.Position = UDim2.new(percent, -8, 0.5, -8)
        
        if callback then 
            local success, err = pcall(callback, value)
            if not success then
                self:Notify("Ошибка: " .. tostring(err), 3)
            end
        end
    end
    
    -- Перетаскивание
    local dragging = false
    
    local function UpdateFromInput(input)
        local relativeX = (input.Position.X - track.AbsolutePosition.X) / track.AbsoluteSize.X
        local newValue = min + relativeX * (max - min)
        UpdateValue(newValue)
    end
    
    local function StartDrag(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or 
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            UpdateFromInput(input)
        end
    end
    
    local function EndDrag(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or 
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = false
        end
    end
    
    track.InputBegan:Connect(StartDrag)
    track.InputEnded:Connect(EndDrag)
    
    local inputChanged
    inputChanged = UserInputService.InputChanged:Connect(function(input)
        if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or 
           input.UserInputType == Enum.UserInputType.Touch) then
            UpdateFromInput(input)
        end
    end)
    
    table.insert(self.Connections, inputChanged)
    
    -- Инициализация
    UpdateValue(value)
    
    return {
        Update = UpdateValue,
        GetValue = function() return value end,
        Destroy = function()
            inputChanged:Disconnect()
        end
    }
end

-- Выпадающий список
function ModMenu:Dropdown(parent, text, options, default, callback)
    local dropdown = Create("Frame", {
        Name = text .. "Dropdown",
        Parent = parent,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 30),
        LayoutOrder = #parent:GetChildren(),
        ClipsDescendants = true
    })
    
    local label = Create("TextLabel", {
        Name = "Label",
        Parent = dropdown,
        Text = text,
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(0.7, 0, 1, 0),
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    local button = Create("TextButton", {
        Name = "Button",
        Parent = dropdown,
        Text = default or options[1],
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundColor3 = Color3.fromRGB(60, 60, 70),
        BorderSizePixel = 0,
        Size = UDim2.new(0.3, 0, 1, 0),
        Position = UDim2.new(0.7, 0, 0, 0),
        AutoButtonColor = false
    })
    
    local buttonCorner = Create("UICorner", {
        CornerRadius = UDim.new(0, 4),
        Parent = button
    })
    
    local list = Create("ScrollingFrame", {
        Name = "List",
        Parent = dropdown,
        BackgroundColor3 = Color3.fromRGB(40, 40, 50),
        BorderSizePixel = 0,
        Size = UDim2.new(0.3, 0, 0, 0),
        Position = UDim2.new(0.7, 0, 1, 5),
        CanvasSize = UDim2.new(0, 0, 0, 0),
        ScrollBarThickness = 3,
        Visible = false,
        ZIndex = 1000
    })
    
    local listLayout = Create("UIListLayout", {
        Parent = list,
        SortOrder = Enum.SortOrder.LayoutOrder
    })
    
    -- Создаем опции
    for i, option in ipairs(options) do
        local optionBtn = Create("TextButton", {
            Name = option,
            Parent = list,
            Text = option,
            Font = Enum.Font.Gotham,
            TextSize = 12,
            TextColor3 = self.Settings.Menu.Text,
            BackgroundColor3 = Color3.fromRGB(50, 50, 60),
            BorderSizePixel = 0,
            Size = UDim2.new(1, 0, 0, 25),
            LayoutOrder = i,
            AutoButtonColor = false,
            ZIndex = 1001
        })
        
        optionBtn.MouseButton1Click:Connect(function()
            button.Text = option
            if callback then 
                local success, err = pcall(callback, option)
                if not success then
                    self:Notify("Ошибка: " .. tostring(err), 3)
                end
            end
            self:ToggleDropdown(list)
        end)
        
        optionBtn.MouseEnter:Connect(function()
            Tween(optionBtn, {BackgroundColor3 = Color3.fromRGB(70, 70, 80)})
        end)
        
        optionBtn.MouseLeave:Connect(function()
            Tween(optionBtn, {BackgroundColor3 = Color3.fromRGB(50, 50, 60)})
        end)
    end
    
    -- Обновляем размер списка
    listLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        list.CanvasSize = UDim2.new(0, 0, 0, listLayout.AbsoluteContentSize.Y)
        list.Size = UDim2.new(0.3, 0, 0, math.min(listLayout.AbsoluteContentSize.Y, 150))
    end)
    
    -- Функция переключения
    button.MouseButton1Click:Connect(function()
        self:ToggleDropdown(list)
    end)
    
    -- Закрытие при клике вне
    local closeConnection
    closeConnection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            if list.Visible then
                local mousePos = input.Position
                local framePos = list.AbsolutePosition
                local frameSize = list.AbsoluteSize
                
                if mousePos.X < framePos.X or mousePos.X > framePos.X + frameSize.X or
                   mousePos.Y < framePos.Y or mousePos.Y > framePos.Y + frameSize.Y then
                    self:ToggleDropdown(list)
                end
            end
        end
    end)
    
    table.insert(self.Connections, closeConnection)
    
    return {
        SetValue = function(value)
            button.Text = value
            if callback then 
                local success, err = pcall(callback, value)
                if not success then
                    self:Notify("Ошибка: " .. tostring(err), 3)
                end
            end
        end,
        GetValue = function() return button.Text end,
        Destroy = function()
            closeConnection:Disconnect()
        end
    }
end

-- Палитра цветов (ИСПРАВЛЕННЫЙ МЕТОД)
function ModMenu:ColorPicker(parent, text, default, callback)
    local picker = Create("Frame", {
        Name = text .. "ColorPicker",
        Parent = parent,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, 0, 0, 30),
        LayoutOrder = #parent:GetChildren()
    })
    
    local label = Create("TextLabel", {
        Name = "Label",
        Parent = picker,
        Text = text,
        Font = Enum.Font.Gotham,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(0.7, 0, 1, 0),
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    local preview = Create("TextButton", {
        Name = "Preview",
        Parent = picker,
        Text = "",
        BackgroundColor3 = default,
        BorderSizePixel = 0,
        Size = UDim2.new(0, 40, 0, 25),
        Position = UDim2.new(0.7, 0, 0.5, -12.5),
        AutoButtonColor = false
    })
    
    local previewCorner = Create("UICorner", {
        CornerRadius = UDim.new(0, 4),
        Parent = preview
    })
    
    local pickerFrame = Create("Frame", {
        Name = "ColorGrid",
        Parent = picker,
        BackgroundColor3 = Color3.fromRGB(40, 40, 50),
        BorderSizePixel = 0,
        Size = UDim2.new(0, 150, 0, 90),
        Position = UDim2.new(0.7, 45, 0.5, -45),
        Visible = false,
        ZIndex = 1000
    })
    
    local pickerCorner = Create("UICorner", {
        CornerRadius = UDim.new(0, 6),
        Parent = pickerFrame
    })
    
    -- Сетка цветов
    local colors = {
        Color3.fromRGB(255, 50, 50),   -- Красный
        Color3.fromRGB(255, 150, 50),  -- Оранжевый
        Color3.fromRGB(255, 255, 50),  -- Желтый
        Color3.fromRGB(150, 255, 50),  -- Лаймовый
        Color3.fromRGB(50, 255, 50),   -- Зеленый
        Color3.fromRGB(50, 255, 150),  -- Бирюзовый
        Color3.fromRGB(50, 255, 255),  -- Голубой
        Color3.fromRGB(50, 150, 255),  -- Синий
        Color3.fromRGB(100, 100, 255), -- Фиолетовый
        Color3.fromRGB(200, 50, 255),  -- Пурпурный
        Color3.fromRGB(255, 50, 200),  -- Розовый
        Color3.fromRGB(255, 50, 100),  -- Малиновый
        Color3.fromRGB(255, 255, 255), -- Белый
        Color3.fromRGB(200, 200, 200), -- Серый
        Color3.new(0.1, 0.1, 0.1)      -- Черный
    }
    
    for i = 1, 15 do
        local colorBtn = Create("TextButton", {
            Name = "Color" .. i,
            Parent = pickerFrame,
            Text = "",
            BackgroundColor3 = colors[i],
            BorderSizePixel = 0,
            Size = UDim2.new(0, 25, 0, 25),
            Position = UDim2.new(0, ((i-1) % 5) * 30 + 2, 0, math.floor((i-1)/5) * 30 + 2),
            AutoButtonColor = false,
            ZIndex = 1001
        })
        
        local colorCorner = Create("UICorner", {
            CornerRadius = UDim.new(0, 4),
            Parent = colorBtn
        })
        
        colorBtn.MouseButton1Click:Connect(function()
            preview.BackgroundColor3 = colors[i]
            if callback then 
                local success, err = pcall(callback, colors[i])
                if not success then
                    self:Notify("Ошибка: " .. tostring(err), 3)
                end
            end
            pickerFrame.Visible = false
        end)
    end
    
    -- Показ/скрытие палитры
    preview.MouseButton1Click:Connect(function()
        pickerFrame.Visible = not pickerFrame.Visible
    end)
    
    -- Закрытие при клике вне
    local closeConnection
    closeConnection = UserInputService.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            if pickerFrame.Visible then
                local mousePos = input.Position
                local framePos = pickerFrame.AbsolutePosition
                local frameSize = pickerFrame.AbsoluteSize
                
                if mousePos.X < framePos.X or mousePos.X > framePos.X + frameSize.X or
                   mousePos.Y < framePos.Y or mousePos.Y > framePos.Y + frameSize.Y then
                    pickerFrame.Visible = false
                end
            end
        end
    end)
    
    table.insert(self.Connections, closeConnection)
    
    return {
        SetColor = function(color)
            preview.BackgroundColor3 = color
            if callback then 
                local success, err = pcall(callback, color)
                if not success then
                    self:Notify("Ошибка: " .. tostring(err), 3)
                end
            end
        end,
        GetColor = function() return preview.BackgroundColor3 end,
        Destroy = function()
            closeConnection:Disconnect()
        end
    }
end

-- Вспомогательные методы

function ModMenu:MakeDraggable(frame, handle)
    handle = handle or frame
    local dragging = false
    local dragInput, dragStart, startPos
    
    local function Update(input)
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, 
                                   startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or 
           input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    handle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or 
           input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input == dragInput then
            Update(input)
        end
    end)
end

function ModMenu:ToggleDropdown(list)
    if list.Visible then
        Tween(list, {Size = UDim2.new(list.Size.X.Scale, list.Size.X.Offset, 0, 0)})
        task.wait(0.2)
        list.Visible = false
    else
        list.Visible = true
        Tween(list, {Size = UDim2.new(list.Size.X.Scale, list.Size.X.Offset, 0, list.CanvasSize.Y.Offset)})
    end
end

function ModMenu:RippleEffect(button)
    local ripple = Create("Frame", {
        Parent = button,
        BackgroundColor3 = Color3.new(1, 1, 1),
        BackgroundTransparency = 0.7,
        Size = UDim2.new(0, 0, 0, 0),
        Position = UDim2.new(0.5, 0, 0.5, 0),
        AnchorPoint = Vector2.new(0.5, 0.5),
        ZIndex = 10
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(1, 0),
        Parent = ripple
    })
    
    Tween(ripple, {Size = UDim2.new(2, 0, 2, 0), BackgroundTransparency = 1}, 0.5)
    
    task.spawn(function()
        task.wait(0.5)
        ripple:Destroy()
    end)
end

function ModMenu:LightenColor(color, amount)
    local r = math.min(color.R * 255 + amount, 255) / 255
    local g = math.min(color.G * 255 + amount, 255) / 255
    local b = math.min(color.B * 255 + amount, 255) / 255
    return Color3.new(r, g, b)
end

-- Основные методы меню

function ModMenu:ToggleMenu()
    self.MenuOpen = not self.MenuOpen
    self.MenuFrame.Visible = self.MenuOpen
    
    -- Обновляем видимость плавающих надписей
    self:UpdateFloatingTextsVisibility()
    
    if self.MenuOpen then
        Tween(self.MainButton, {BackgroundTransparency = 0.5})
        self.MainButton.Text = "✕"
        self:Notify("Меню открыто", 1)
    else
        Tween(self.MainButton, {BackgroundTransparency = 0})
        self.MainButton.Text = "≡"
        self:Notify("Меню закрыто", 1)
    end
end

function ModMenu:ToggleSettings()
    self.SettingsFrame.Visible = not self.SettingsFrame.Visible
end

function ModMenu:Notify(text, duration)
    duration = duration or 3
    
    local notification = Create("Frame", {
        Name = "Notification",
        Parent = self.GUI,
        BackgroundColor3 = Color3.fromRGB(30, 30, 40),
        BackgroundTransparency = 0.1,
        Size = UDim2.new(0, 300, 0, 60),
        Position = UDim2.new(1, -320, 1, -80),
        ZIndex = 10000
    })
    
    local corner = Create("UICorner", {
        CornerRadius = UDim.new(0, 8),
        Parent = notification
    })
    
    local title = Create("TextLabel", {
        Name = "Title",
        Parent = notification,
        Text = "Уведомление",
        Font = Enum.Font.GothamBold,
        TextSize = 14,
        TextColor3 = self.Settings.Menu.Accent,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -20, 0, 20),
        Position = UDim2.new(0, 10, 0, 5),
        TextXAlignment = Enum.TextXAlignment.Left
    })
    
    local message = Create("TextLabel", {
        Name = "Message",
        Parent = notification,
        Text = text,
        Font = Enum.Font.Gotham,
        TextSize = 12,
        TextColor3 = self.Settings.Menu.Text,
        BackgroundTransparency = 1,
        Size = UDim2.new(1, -20, 1, -30),
        Position = UDim2.new(0, 10, 0, 25),
        TextXAlignment = Enum.TextXAlignment.Left,
        TextWrapped = true
    })
    
    -- Анимация появления
    notification.Position = UDim2.new(1, 300, 1, -80)
    Tween(notification, {Position = UDim2.new(1, -320, 1, -80)})
    
    -- Автоматическое удаление
    task.spawn(function()
        task.wait(duration)
        Tween(notification, {Position = UDim2.new(1, 300, 1, -80)})
        task.wait(0.3)
        notification:Destroy()
    end)
end

-- Инициализация систем

function ModMenu:InitSystems()
    -- ESP система
    self:InitESP()
    
    -- Aimbot система
    self:InitAimbot()
    
    -- Visual система
    self:InitVisual()
    
    -- Player система
    self:InitPlayer()
end

function ModMenu:InitESP()
    self.ESP.Objects = {}
    
    local function UpdateESP()
        if not self.Settings.ESP.Enabled then
            for _, obj in pairs(self.ESP.Objects) do
                if obj then
                    obj:Destroy()
                end
            end
            self.ESP.Objects = {}
            return
        end
        
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= PLAYER and player.Character then
                local character = player.Character
                local root = character:FindFirstChild("HumanoidRootPart")
                
                if root then
                    -- Проверка дистанции
                    if PLAYER.Character and PLAYER.Character:FindFirstChild("HumanoidRootPart") then
                        local distance = (root.Position - PLAYER.Character.HumanoidRootPart.Position).Magnitude
                        if distance > self.Settings.ESP.MaxDistance then
                            continue
                        end
                    end
                    
                    -- ESP логика
                    -- (упрощено для примера)
                end
            end
        end
    end
    
    -- Оптимизированное обновление
    local lastUpdate = 0
    table.insert(self.Connections, RunService.RenderStepped:Connect(function(deltaTime)
        lastUpdate = lastUpdate + deltaTime
        if lastUpdate >= 0.1 then  -- Обновляем каждые 0.1 секунды
            UpdateESP()
            lastUpdate = 0
        end
    end))
end

function ModMenu:InitAimbot()
    -- Базовая реализация аимбота
    table.insert(self.Connections, RunService.RenderStepped:Connect(function()
        if self.Settings.Aimbot.Enabled then
            -- Логика аимбота
        end
    end))
end

function ModMenu:InitVisual()
    local function UpdateFullbright()
        if self.Settings.Visual.Fullbright then
            Lighting.GlobalShadows = false
            Lighting.ClockTime = 14
        else
            Lighting.GlobalShadows = true
        end
    end
    
    -- Отслеживание изменений настроек
    self:OnSettingChanged("Visual.Fullbright", UpdateFullbright)
end

function ModMenu:InitPlayer()
    local function UpdateSpeed()
        if PLAYER.Character then
            local humanoid = PLAYER.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = self.Settings.Player.Speed
            end
        end
    end
    
    table.insert(self.Connections, PLAYER.CharacterAdded:Connect(function(character)
        character:WaitForChild("Humanoid")
        UpdateSpeed()
    end))
    
    self:OnSettingChanged("Player.Speed", UpdateSpeed)
end

-- Отслеживание изменений настроек
function ModMenu:OnSettingChanged(settingPath, callback)
    local parts = string.split(settingPath, ".")
    local current = self.Settings
    
    for i = 1, #parts - 1 do
        if not current[parts[i]] then
            current[parts[i]] = {}
        end
        current = current[parts[i]]
    end
    
    local lastPart = parts[#parts]
    
    local oldValue = current[lastPart]
    local metaTable = getmetatable(current) or {}
    local oldIndex = metaTable.__index
    
    setmetatable(current, {
        __index = oldIndex,
        __newindex = function(t, k, v)
            if k == lastPart then
                rawset(t, k, v)
                local success, err = pcall(callback, v)
                if not success then
                    self:Notify("Ошибка в настройке: " .. tostring(err), 3)
                end
            else
                rawset(t, k, v)
            end
        end
    })
end

-- Обновление интерфейса
function ModMenu:UpdateColors()
    self:Notify("Цвета меню обновлены", 1.5)
end

function ModMenu:UpdateTransparency()
    if self.MenuFrame then
        self.MenuFrame.BackgroundTransparency = self.Settings.Menu.Transparency
    end
    if self.SettingsFrame then
        self.SettingsFrame.BackgroundTransparency = self.Settings.Menu.Transparency
    end
end

function ModMenu:UpdateFullbright()
    self:Notify("Освещение обновлено", 1.5)
end

function ModMenu:UpdateESP()
    self:Notify("ESP обновлено", 1.5)
end

-- Система полета
function ModMenu:ToggleFly(enabled)
    if enabled then
        self:Notify("Полёт включен", 2)
    else
        self:Notify("Полёт выключен", 2)
    end
end

-- NoClip система
function ModMenu:ToggleNoClip(enabled)
    if enabled then
        self:Notify("NoClip включен", 2)
    else
        self:Notify("NoClip выключен", 2)
    end
end

-- API методы
function ModMenu:Destroy()
    for _, connection in ipairs(self.Connections) do
        if type(connection) == "table" and connection.Disconnect then
            connection:Disconnect()
        elseif type(connection) == "userdata" then
            connection:Disconnect()
        end
    end
    
    if self.GUI then
        self.GUI:Destroy()
    end
    
    self.Active = false
    self:Notify("Меню уничтожено", 2)
end

function ModMenu:GetSetting(path)
    local parts = string.split(path, ".")
    local current = self.Settings
    
    for _, part in ipairs(parts) do
        if current[part] then
            current = current[part]
        else
            return nil
        end
    end
    
    return current
end

function ModMenu:SetSetting(path, value)
    local parts = string.split(path, ".")
    local current = self.Settings
    
    for i = 1, #parts - 1 do
        if not current[parts[i]] then
            current[parts[i]] = {}
        end
        current = current[parts[i]]
    end
    
    current[parts[#parts]] = value
end

-- Быстрый старт
function ModMenu:QuickStart()
    -- Добавляем базовые табы
    local homeTab = self:AddTab("Home", "🏠")
    local playerTab = self:AddTab("Player", "👤")
    local visualTab = self:AddTab("Visual", "👁️")
    local worldTab = self:AddTab("World", "🌍")
    local miscTab = self:AddTab("Misc", "⚙️")
    
    -- Добавляем элементы в домашний таб
    self:Btn(homeTab, "Добро пожаловать!", function()
        self:Notify("Привет! Это меню v" .. self.Version, 3)
    end)
    
    self:Btn(homeTab, "Информация", function()
        self:Notify("Автор: Фатима ♥️", 3)
    end)
    
    -- Добавляем элементы в игровой таб
    self:Toggle(playerTab, "Бессмертие", false, function(value)
        if PLAYER.Character then
            local humanoid = PLAYER.Character:FindFirstChild("Humanoid")
            if humanoid then
                if value then
                    humanoid.Health = math.huge
                end
            end
        end
    end)
    
    self:Slider(playerTab, "Скорость", 16, 500, 16, 1, function(value)
        if PLAYER.Character then
            local humanoid = PLAYER.Character:FindFirstChild("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = value
            end
        end
    end)
    
    self:Btn(playerTab, "Телепорт к спавну", function()
        if PLAYER.Character then
            local spawn = workspace:FindFirstChild("SpawnLocation")
            if spawn then
                PLAYER.Character:SetPrimaryPartCFrame(spawn.CFrame)
                self:Notify("Телепортирован к спавну", 2)
            else
                self:Notify("Спавн не найден", 2)
            end
        end
    end)
    
    -- Добавляем элементы в визуальный таб
    self:Toggle(visualTab, "Fullbright", false, function(value)
        self.Settings.Visual.Fullbright = value
    end)
    
    self:Slider(visualTab, "Яркость", 0, 10, 1, 0.1, function(value)
        Lighting.Brightness = value
    end)
    
    return self
end

-- Экспорт
return {
    new = function(menuName)
        return ModMenu.new(menuName):QuickStart()
    end,
    
    -- Быстрые методы для разработчиков
    Create = Create,
    Tween = Tween,
    Round = Round
}
