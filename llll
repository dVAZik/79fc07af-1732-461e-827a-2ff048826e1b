-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–æ–≤ —Å –ø–æ–ª–Ω—ã–º –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ–º –∏ –∑–∞–º–µ–Ω–æ–π
-- –ê–≤—Ç–æ—Ä: AI Assistant
-- –í–µ—Ä—Å–∏—è: 3.1 (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∞ –æ—à–∏–±–∫–∞ nil income)

-- –ü–æ–ª—É—á–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –º–æ–¥—É–ª–∏
local Portfolio = require(game:GetService("ReplicatedStorage").Modules.Game.PortfolioController)
local Building = require(game:GetService("ReplicatedStorage").Modules.Data.Building)
local PlayerDataClient = require(game:GetService("ReplicatedStorage").Modules.PlayerDataClient)

-- –ü—É—Ç–∏ –∫ RemoteEvents –∏ Functions
local NetworkPath = game:GetService("ReplicatedStorage").Modules.NetworkClient

-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
local MIN_STARS = 4  -- –ú–∏–Ω–∏–º—É–º –∑–≤–µ–∑–¥ –¥–ª—è —É–¥–µ—Ä–∂–∞–Ω–∏—è –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
local CHECK_INTERVAL = 15  -- –ò–Ω—Ç–µ—Ä–≤–∞–ª –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
local AUTO_DENY_BAD_APPLICANTS = true  -- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—Ç–∫–ª–æ–Ω—è—Ç—å –ø–ª–æ—Ö–∏—Ö (<3 –∑–≤–µ–∑–¥)
local AUTO_ACCEPT_GOOD_APPLICANTS = true  -- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–Ω–∏–º–∞—Ç—å —Ö–æ—Ä–æ—à–∏—Ö (‚â•4 –∑–≤–µ–∑–¥)

-- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
local isRunning = false
local cycleCount = 0
local lastPropertyCount = 0
local processedRenters = {}
local processedApplicants = {}
local propertyCache = {}

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
local function log(message, type)
    local prefix = ""
    if type == "success" then
        prefix = "‚úÖ "
    elseif type == "warning" then
        prefix = "‚ö†Ô∏è "
    elseif type == "error" then
        prefix = "‚ùå "
    elseif type == "info" then
        prefix = "üìå "
    elseif type == "money" then
        prefix = "üí∞ "
    elseif type == "spot" then
        prefix = "üîÑ "
    else
        prefix = "üìù "
    end
    print(prefix .. message)
end

-- –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ –æ–±—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –º–µ—Å—Ç –≤ –æ–±—ä–µ–∫—Ç–µ
local function calculateTotalSpots(propertyUID)
    if not propertyUID then return 0 end
    
    local property = Portfolio.GetAll(propertyUID)
    if not property or property.BuildingType == "Empty" then return 0 end
    
    local buildingData = Building[property.BuildingType]
    if not buildingData then return 0 end
    
    local totalSpots = buildingData.Spots or 0
    
    -- –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Å—Ç–∞ –æ—Ç —É–ª—É—á—à–µ–Ω–∏–π
    if property.Built then
        for _, upgrade in ipairs(property.Built) do
            if upgrade ~= "Main" and buildingData.Upgrades and buildingData.Upgrades[upgrade] then
                totalSpots = totalSpots + (buildingData.Upgrades[upgrade].AddedRenters or 0)
            end
        end
    end
    
    return totalSpots
end

-- –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ –∑–∞–Ω—è—Ç—ã—Ö –º–µ—Å—Ç
local function calculateOccupiedSpots(propertyUID)
    if not propertyUID then return 0 end
    
    local property = Portfolio.GetAll(propertyUID)
    if not property or not property.Renters then return 0 end
    
    local occupied = 0
    for _ in pairs(property.Renters) do
        occupied = occupied + 1
    end
    
    return occupied
end

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –ª–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω –æ–±—ä–µ–∫—Ç
local function isPropertyFullyOccupied(propertyUID)
    if not propertyUID then return false end
    
    local totalSpots = calculateTotalSpots(propertyUID)
    if totalSpots == 0 then return false end
    
    local occupiedSpots = calculateOccupiedSpots(propertyUID)
    return occupiedSpots >= totalSpots
end

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –µ—Å—Ç—å –ª–∏ —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞
local function hasAvailableSpots(propertyUID)
    if not propertyUID then return false end
    
    local totalSpots = calculateTotalSpots(propertyUID)
    local occupiedSpots = calculateOccupiedSpots(propertyUID)
    return occupiedSpots < totalSpots
end

-- –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç
local function getAvailableSpotsCount(propertyUID)
    if not propertyUID then return 0 end
    
    local totalSpots = calculateTotalSpots(propertyUID)
    local occupiedSpots = calculateOccupiedSpots(propertyUID)
    return math.max(0, totalSpots - occupiedSpots)
end

-- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∫—ç—à–∞ –æ–±—ä–µ–∫—Ç–æ–≤
local function updatePropertyCache()
    local allProperties = Portfolio.GetPortfolio()
    local newCache = {}
    local newProperties = 0
    
    for propertyUID, property in pairs(allProperties) do
        if propertyUID and property then
            local totalSpots = calculateTotalSpots(propertyUID)
            local occupiedSpots = calculateOccupiedSpots(propertyUID)
            local availableSpots = getAvailableSpotsCount(propertyUID)
            
            newCache[propertyUID] = {
                BuildingType = property.BuildingType,
                District = property.District,
                Address = property.Address,
                Income = property.Income or 0,
                Renters = property.Renters and #property.Renters or 0,
                TotalSpots = totalSpots,
                OccupiedSpots = occupiedSpots,
                AvailableSpots = availableSpots,
                FullyOccupied = isPropertyFullyOccupied(propertyUID)
            }
            
            -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–π –ª–∏ —ç—Ç–æ –æ–±—ä–µ–∫—Ç
            if not propertyCache[propertyUID] and property.BuildingType ~= "Empty" then
                newProperties = newProperties + 1
                log(string.format("–û–±–Ω–∞—Ä—É–∂–µ–Ω –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç: %s (%s) - %d/%d –º–µ—Å—Ç", 
                    propertyUID, property.BuildingType, occupiedSpots, totalSpots), "info")
            end
        end
    end
    
    -- –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫
    if newProperties > 0 then
        log(string.format("üéâ –ù–∞–π–¥–µ–Ω–æ %d –Ω–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤!", newProperties), "success")
    end
    
    propertyCache = newCache
    lastPropertyCount = #allProperties
    
    return newProperties
end

-- –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ –¥–æ—Ö–æ–¥–∞ –æ—Ç –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
local function calculateRenterIncome(propertyUID, renter)
    if not propertyUID or not renter then
        return 0
    end
    
    local property = Portfolio.GetAll(propertyUID)
    if not property or property.BuildingType == "Empty" then 
        return 0 
    end
    
    -- –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∑–¥–∞–Ω–∏–∏
    local buildingData = Building[property.BuildingType]
    if not buildingData then return 0 end
    
    -- –ë–∞–∑–æ–≤—ã–π –¥–æ—Ö–æ–¥
    local baseRent = buildingData.BaseRent or 0
    
    -- –î–æ–±–∞–≤–ª—è–µ–º –±–æ–Ω—É—Å—ã –æ—Ç —É–ª—É—á—à–µ–Ω–∏–π
    if property.Built then
        for _, upgrade in ipairs(property.Built) do
            if upgrade ~= "Main" and buildingData.Upgrades and buildingData.Upgrades[upgrade] then
                baseRent = baseRent + (buildingData.Upgrades[upgrade].AddedRent or 0)
            end
        end
    end
    
    -- –ú–Ω–æ–∂–∏—Ç–µ–ª—å –∑–≤–µ–∑–¥: 1 –∑–≤–µ–∑–¥–∞ = 50%, 5 –∑–≤–µ–∑–¥ = 250%
    local starMultiplier = 0.5 + (renter.Stars or 1) * 0.5
    
    -- –ë–æ–Ω—É—Å –æ—Ç –±—É—Ö–≥–∞–ª—Ç–µ—Ä–∞
    local accountantBonus = 1
    local workers = PlayerDataClient.Get("Workers")
    if workers and workers.Accountant then
        accountantBonus = 1 + workers.Accountant * 0.2
    end
    
    local totalIncome = baseRent * starMultiplier * accountantBonus
    return math.floor((totalIncome or 0) * 100) / 100  -- –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ 2 –∑–Ω–∞–∫–æ–≤
end

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞—è–≤–æ–∫ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏ (–æ—Ç –ª—É—á—à–µ–π –∫ —Ö—É–¥—à–µ–π)
local function getAllApplicantsSorted(propertyUID)
    if not propertyUID then return {} end
    
    local property = Portfolio.GetAll(propertyUID)
    if not property or not property.Applicants then return {} end
    
    local applicants = {}
    
    for applicantId, applicant in pairs(property.Applicants) do
        if applicantId and applicant then
            local cacheKey = propertyUID .. "_" .. applicantId
            if not processedApplicants[cacheKey] then
                local income = calculateRenterIncome(propertyUID, applicant)
                if income then
                    table.insert(applicants, {
                        id = applicantId,
                        income = income,
                        stars = applicant.Stars or 1,
                        data = applicant
                    })
                end
            end
        end
    end
    
    -- –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∑–≤–µ–∑–¥–∞–º (–æ—Ç –±–æ–ª—å—à–µ–≥–æ –∫ –º–µ–Ω—å—à–µ–º—É), –∑–∞—Ç–µ–º –ø–æ –¥–æ—Ö–æ–¥—É
    if #applicants > 0 then
        table.sort(applicants, function(a, b)
            if a.stars == b.stars then
                return (a.income or 0) > (b.income or 0)
            end
            return a.stars > b.stars
        end)
    end
    
    return applicants
end

-- –§—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–æ–≤ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ –¥–æ—Ö–æ–¥–Ω–æ—Å—Ç–∏ (–æ—Ç —Ö—É–¥—à–µ–≥–æ –∫ –ª—É—á—à–µ–º—É)
local function getAllRentersSorted(propertyUID)
    if not propertyUID then return {} end
    
    local property = Portfolio.GetAll(propertyUID)
    if not property or not property.Renters then return {} end
    
    local renters = {}
    
    for renterId, renter in pairs(property.Renters) do
        if renterId and renter then
            local cacheKey = propertyUID .. "_" .. renterId
            if not processedRenters[cacheKey] then
                local income = calculateRenterIncome(propertyUID, renter)
                if income then
                    table.insert(renters, {
                        id = renterId,
                        income = income,
                        stars = renter.Stars or 1,
                        data = renter
                    })
                end
            end
        end
    end
    
    -- –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∑–≤–µ–∑–¥–∞–º (–æ—Ç –º–µ–Ω—å—à–µ–≥–æ –∫ –±–æ–ª—å—à–µ–º—É), –∑–∞—Ç–µ–º –ø–æ –¥–æ—Ö–æ–¥—É
    if #renters > 0 then
        table.sort(renters, function(a, b)
            if a.stars == b.stars then
                return (a.income or 0) < (b.income or 0)
            end
            return a.stars < b.stars
        end)
    end
    
    return renters
end

-- –§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–Ω—è—Ç–∏—è –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
local function acceptApplicant(propertyUID, applicantId)
    if not propertyUID or not applicantId then
        return false, "–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"
    end
    
    local args = {[1] = propertyUID, [2] = applicantId}
    local success, result = pcall(function()
        return NetworkPath.FunctionMap.Tenancy.SelectTenant:InvokeServer(unpack(args))
    end)
    
    if success then
        processedApplicants[propertyUID .. "_" .. applicantId] = true
        return true, "–£—Å–ø–µ—à–Ω–æ –ø—Ä–∏–Ω—è—Ç"
    else
        return false, "–û—à–∏–±–∫–∞: " .. tostring(result)
    end
end

-- –§—É–Ω–∫—Ü–∏—è –≤—ã—Å–µ–ª–µ–Ω–∏—è –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
local function evictRenter(propertyUID, renterId)
    if not propertyUID or not renterId then
        return false, "–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"
    end
    
    local args = {[1] = propertyUID, [2] = renterId}
    local success, result = pcall(function()
        return NetworkPath.FunctionMap.Tenancy.Evict:InvokeServer(unpack(args))
    end)
    
    if success then
        processedRenters[propertyUID .. "_" .. renterId] = true
        return true, "–£—Å–ø–µ—à–Ω–æ –≤—ã—Å–µ–ª–µ–Ω"
    else
        return false, "–û—à–∏–±–∫–∞: " .. tostring(result)
    end
end

-- –§—É–Ω–∫—Ü–∏—è –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è –∑–∞—è–≤–∫–∏
local function denyApplicant(propertyUID, applicantId)
    if not propertyUID or not applicantId then
        return false, "–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã"
    end
    
    local args = {[1] = propertyUID, [2] = applicantId}
    local success, result = pcall(function()
        return NetworkPath.EventMap.DenyApplicant:FireServer(unpack(args))
    end)
    
    if success then
        processedApplicants[propertyUID .. "_" .. applicantId] = true
        return true, "–£—Å–ø–µ—à–Ω–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∞"
    else
        return false, "–û—à–∏–±–∫–∞: " .. tostring(result)
    end
end

-- –§—É–Ω–∫—Ü–∏—è –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç –ª—É—á—à–∏–º–∏ –∑–∞—è–≤–∫–∞–º–∏
local function fillAllAvailableSpots(propertyUID)
    if not propertyUID then return 0, 0 end
    
    local availableSpots = getAvailableSpotsCount(propertyUID)
    if availableSpots <= 0 then return 0, 0 end
    
    local applicants = getAllApplicantsSorted(propertyUID)
    if #applicants == 0 then return 0, 0 end
    
    local acceptedCount = 0
    local totalIncomeGain = 0
    
    -- –ü—Ä–∏–Ω–∏–º–∞–µ–º –ª—É—á—à–∏—Ö –∑–∞—è–≤–æ–∫ –ø–æ–∫–∞ –µ—Å—Ç—å –º–µ—Å—Ç–∞
    for i = 1, math.min(availableSpots, #applicants) do
        local applicant = applicants[i]
        if applicant and applicant.stars and applicant.stars >= MIN_STARS then
            local success, message = acceptApplicant(propertyUID, applicant.id)
            if success then
                acceptedCount = acceptedCount + 1
                totalIncomeGain = totalIncomeGain + (applicant.income or 0)
                log(string.format("  [%s] –ü—Ä–∏–Ω—è—Ç %s (%d‚≠ê, +$%.2f)", 
                    propertyUID, applicant.id, applicant.stars, applicant.income or 0), "spot")
                
                -- –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –ø—Ä–∏–Ω—è—Ç–∏—è–º–∏
                task.wait(0.3)
            else
                log(string.format("  [%s] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ %s: %s", 
                    propertyUID, applicant.id, message), "error")
            end
        end
    end
    
    return acceptedCount, totalIncomeGain
end

-- –§—É–Ω–∫—Ü–∏—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
local function optimizeFullyOccupiedProperty(propertyUID)
    if not propertyUID then
        log("–û—à–∏–±–∫–∞: propertyUID –Ω–µ —É–∫–∞–∑–∞–Ω", "error")
        return 0, 0
    end
    
    local currentRenters = getAllRentersSorted(propertyUID)
    local currentApplicants = getAllApplicantsSorted(propertyUID)
    
    if #currentRenters == 0 or #currentApplicants == 0 then
        log(string.format("  [%s] –ù–µ—Ç –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–æ–≤ (%d) –∏–ª–∏ –∑–∞—è–≤–æ–∫ (%d) –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏", 
            propertyUID, #currentRenters, #currentApplicants), "info")
        return 0, 0
    end
    
    local replacementsMade = 0
    local totalIncomeIncrease = 0
    local totalSpots = calculateTotalSpots(propertyUID)
    
    log(string.format("  [%s] –û–±—ä–µ–∫—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω (%d/%d), –ø—Ä–æ–≤–µ—Ä—è—é –∑–∞–º–µ–Ω—ã...", 
        propertyUID, #currentRenters, totalSpots), "info")
    
    -- –ü—Ä–æ—Ö–æ–¥–∏–º –ø–æ –≤—Å–µ–º –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞–º –æ—Ç —Ö—É–¥—à–µ–≥–æ –∫ –ª—É—á—à–µ–º—É
    for renterIndex = 1, #currentRenters do
        local worstRenter = currentRenters[renterIndex]
        
        if not worstRenter or not worstRenter.income then
            log(string.format("  [%s] –ü—Ä–æ–ø—É—Å–∫ –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –¥–æ—Ö–æ–¥–µ", propertyUID), "warning")
            break
        end
        
        -- –ò—â–µ–º –ª—É—á—à—É—é –∑–∞—è–≤–∫—É –¥–ª—è –∑–∞–º–µ–Ω—ã —ç—Ç–æ–≥–æ –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
        for applicantIndex = 1, #currentApplicants do
            local bestApplicant = currentApplicants[applicantIndex]
            
            if not bestApplicant or not bestApplicant.income then
                log(string.format("  [%s] –ü—Ä–æ–ø—É—Å–∫ –∑–∞—è–≤–∫–∏: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –¥–æ—Ö–æ–¥–µ", propertyUID), "warning")
                break
            end
            
            -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—Ç–æ–∏—Ç –ª–∏ –∑–∞–º–µ–Ω—è—Ç—å
            if bestApplicant.income > worstRenter.income and bestApplicant.stars >= MIN_STARS then
                local profitDifference = bestApplicant.income - worstRenter.income
                
                log(string.format("  [%s] –ù–∞–π–¥–µ–Ω–∞ –≤—ã–≥–æ–¥–Ω–∞—è –∑–∞–º–µ–Ω–∞: %s (%d‚≠ê, $%.2f) ‚Üí %s (%d‚≠ê, $%.2f) [+$%.2f]", 
                    propertyUID, worstRenter.id, worstRenter.stars, worstRenter.income,
                    bestApplicant.id, bestApplicant.stars, bestApplicant.income, profitDifference), "info")
                
                -- –í—ã—Å–µ–ª—è–µ–º —Ö—É–¥—à–µ–≥–æ –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–∞
                local success1, message1 = evictRenter(propertyUID, worstRenter.id)
                if success1 then
                    task.wait(0.5)
                    
                    -- –ü—Ä–∏–Ω–∏–º–∞–µ–º –ª—É—á—à—É—é –∑–∞—è–≤–∫—É
                    local success2, message2 = acceptApplicant(propertyUID, bestApplicant.id)
                    if success2 then
                        replacementsMade = replacementsMade + 1
                        totalIncomeIncrease = totalIncomeIncrease + profitDifference
                        
                        log(string.format("  [%s] ‚úÖ –£—Å–ø–µ—à–Ω–∞—è –∑–∞–º–µ–Ω–∞: +$%.2f", propertyUID, profitDifference), "success")
                        
                        -- –£–¥–∞–ª—è–µ–º –∑–∞–º–µ–Ω–µ–Ω–Ω—ã—Ö –∏–∑ —Å–ø–∏—Å–∫–æ–≤
                        table.remove(currentRenters, renterIndex)
                        table.remove(currentApplicants, applicantIndex)
                        
                        -- –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Å —ç—Ç–æ–≥–æ –∂–µ –∏–Ω–¥–µ–∫—Å–∞, —Ç–∞–∫ –∫–∞–∫ –º–∞—Å—Å–∏–≤ –∏–∑–º–µ–Ω–∏–ª—Å—è
                        renterIndex = renterIndex - 1
                        break
                    else
                        log(string.format("  [%s] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ –ø–æ—Å–ª–µ –≤—ã—Å–µ–ª–µ–Ω–∏—è: %s", 
                            propertyUID, message2), "error")
                    end
                else
                    log(string.format("  [%s] ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Å–µ–ª–µ–Ω–∏–∏: %s", propertyUID, message1), "error")
                end
            end
        end
    end
    
    return replacementsMade, totalIncomeIncrease
end

-- –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –æ–¥–Ω–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞
local function optimizeProperty(propertyUID)
    if not propertyUID then
        return "error|–ù–µ —É–∫–∞–∑–∞–Ω propertyUID"
    end
    
    local property = Portfolio.GetAll(propertyUID)
    if not property or property.BuildingType == "Empty" then
        return "skip_empty"
    end
    
    local buildingData = Building[property.BuildingType]
    if not buildingData or not buildingData.Spots or buildingData.Spots == 0 then
        return "skip_no_spots"
    end
    
    local totalSpots = calculateTotalSpots(propertyUID)
    local occupiedSpots = calculateOccupiedSpots(propertyUID)
    local availableSpots = getAvailableSpotsCount(propertyUID)
    local fullyOccupied = isPropertyFullyOccupied(propertyUID)
    local hasApplicants = property.Applicants and next(property.Applicants)
    
    log(string.format("[%s] %s: %d/%d –º–µ—Å—Ç (%d —Å–≤–æ–±–æ–¥–Ω–æ)", 
        propertyUID, property.BuildingType, occupiedSpots, totalSpots, availableSpots), "info")
    
    -- –ï—Å–ª–∏ –Ω–µ—Ç –∑–∞—è–≤–æ–∫, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
    if not hasApplicants then
        return "no_applicants"
    end
    
    -- –°–¶–ï–ù–ê–†–ò–ô 1: –ï—Å—Ç—å —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞
    if availableSpots > 0 then
        log(string.format("  [%s] –ï—Å—Ç—å %d —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç, –∑–∞–ø–æ–ª–Ω—è—é...", propertyUID, availableSpots), "spot")
        
        local filled, incomeGain = fillAllAvailableSpots(propertyUID)
        if filled > 0 then
            return string.format("filled|%d|+$%.2f", filled, incomeGain)
        end
    end
    
    -- –°–¶–ï–ù–ê–†–ò–ô 2: –û–±—ä–µ–∫—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–ø–æ–ª–Ω–µ–Ω
    if fullyOccupied then
        log(string.format("  [%s] –û–±—ä–µ–∫—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–ø–æ–ª–Ω–µ–Ω, –ø—Ä–æ–≤–µ—Ä—è—é —É–ª—É—á—à–µ–Ω–∏—è...", propertyUID), "info")
        
        local replaced, incomeIncrease = optimizeFullyOccupiedProperty(propertyUID)
        if replaced > 0 then
            return string.format("replaced|%d|+$%.2f", replaced, incomeIncrease)
        end
    end
    
    -- –°–¶–ï–ù–ê–†–ò–ô 3: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø–ª–æ—Ö–∏—Ö –∑–∞—è–≤–æ–∫
    if AUTO_DENY_BAD_APPLICANTS and hasApplicants then
        local deniedCount = 0
        for applicantId, applicant in pairs(property.Applicants) do
            if applicantId and applicant then
                local cacheKey = propertyUID .. "_" .. applicantId
                if not processedApplicants[cacheKey] then
                    local stars = applicant.Stars or 1
                    if stars < 3 then
                        local success, message = denyApplicant(propertyUID, applicantId)
                        if success then
                            deniedCount = deniedCount + 1
                            log(string.format("  [%s] –û—Ç–∫–ª–æ–Ω–µ–Ω–∞ –ø–ª–æ—Ö–∞—è –∑–∞—è–≤–∫–∞ %s (%d‚≠ê)", 
                                propertyUID, applicantId, stars), "warning")
                        end
                    end
                end
            end
        end
        
        if deniedCount > 0 then
            return string.format("denied|%d", deniedCount)
        end
    end
    
    return "no_changes"
end

-- –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ –æ–±—â–µ–≥–æ –¥–æ—Ö–æ–¥–∞ –ø–æ—Ä—Ç—Ñ–µ–ª—è
local function calculateTotalPortfolioIncome()
    local allProperties = Portfolio.GetPortfolio()
    local total = 0
    
    for _, property in pairs(allProperties) do
        if property and property.Income then
            total = total + property.Income
        end
    end
    
    return total
end

-- –§—É–Ω–∫—Ü–∏—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤—Å–µ–≥–æ –ø–æ—Ä—Ç—Ñ–µ–ª—è
local function optimizeAllProperties()
    cycleCount = cycleCount + 1
    log(string.format("\nüîÑ –¶–ò–ö–õ –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò #%d", cycleCount), "info")
    
    -- –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–æ—Ö–æ–¥ –¥–æ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    local incomeBefore = calculateTotalPortfolioIncome()
    
    -- –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à –∏ –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã
    local newProperties = updatePropertyCache()
    
    local allProperties = Portfolio.GetPortfolio()
    local optimizedCount = 0
    local totalProperties = 0
    
    -- –°–æ–±–∏—Ä–∞–µ–º –æ–±—â—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    local totalSpotsAll = 0
    local occupiedSpotsAll = 0
    
    for propertyUID, property in pairs(allProperties) do
        if propertyUID and property then
            totalProperties = totalProperties + 1
            totalSpotsAll = totalSpotsAll + calculateTotalSpots(propertyUID)
            occupiedSpotsAll = occupiedSpotsAll + calculateOccupiedSpots(propertyUID)
        end
    end
    
    local percentageOccupied = totalSpotsAll > 0 and (occupiedSpotsAll / totalSpotsAll * 100) or 0
    
    log(string.format("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: %d –æ–±—ä–µ–∫—Ç–æ–≤ | %d/%d –º–µ—Å—Ç (%.1f%%) | –î–æ—Ö–æ–¥: $%.2f", 
        totalProperties, occupiedSpotsAll, totalSpotsAll, percentageOccupied, incomeBefore), "money")
    
    -- –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º –∫–∞–∂–¥—ã–π –æ–±—ä–µ–∫—Ç
    for propertyUID, property in pairs(allProperties) do
        if property and property.BuildingType and property.BuildingType ~= "Empty" then
            local result = optimizeProperty(propertyUID)
            
            if result:find("filled|") then
                local parts = result:split("|")
                optimizedCount = optimizedCount + 1
                log(string.format("[%s] ‚úÖ –ó–∞–ø–æ–ª–Ω–µ–Ω–æ %s –º–µ—Å—Ç %s", 
                    propertyUID, parts[2], parts[3]), "success")
            elseif result:find("replaced|") then
                local parts = result:split("|")
                optimizedCount = optimizedCount + 1
                log(string.format("[%s] üîÑ –ó–∞–º–µ–Ω–µ–Ω–æ %s –∞—Ä–µ–Ω–¥–∞—Ç–æ—Ä–æ–≤ %s", 
                    propertyUID, parts[2], parts[3]), "spot")
            elseif result:find("denied|") then
                local parts = result:split("|")
                optimizedCount = optimizedCount + 1
                log(string.format("[%s] üóëÔ∏è –û—Ç–∫–ª–æ–Ω–µ–Ω–æ %s –ø–ª–æ—Ö–∏—Ö –∑–∞—è–≤–æ–∫", 
                    propertyUID, parts[2]), "warning")
            elseif result:find("error|") then
                log(string.format("[%s] ‚ùå –û—à–∏–±–∫–∞: %s", propertyUID, result), "error")
            end
            
            -- –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –æ–±—ä–µ–∫—Ç–∞–º–∏
            task.wait(0.2)
        end
    end
    
    -- –û–±–Ω–æ–≤–ª—è–µ–º –¥–æ—Ö–æ–¥ –ø–æ—Å–ª–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    local incomeAfter = calculateTotalPortfolioIncome()
    local incomeChange = incomeAfter - incomeBefore
    
    -- –û—á–∏—â–∞–µ–º –∫—ç—à
    for key in pairs(processedRenters) do
        if math.random() < 0.1 then
            processedRenters[key] = nil
        end
    end
    
    for key in pairs(processedApplicants) do
        if math.random() < 0.2 then
            processedApplicants[key] = nil
        end
    end
    
    -- –û—Ç—á–µ—Ç –æ —Ü–∏–∫–ª–µ
    log(string.format("\nüìà –†–ï–ó–£–õ–¨–¢–ê–¢–´ –¶–ò–ö–õ–ê #%d:", cycleCount), "info")
    
    if incomeChange > 0 then
        log(string.format("   üí∞ –ü—Ä–∏—Ä–æ—Å—Ç –¥–æ—Ö–æ–¥–∞: +$%.2f (%.1f%%)", 
            incomeChange, (incomeChange / incomeBefore) * 100), "money")
        log(string.format("   üí∞ –ù–æ–≤—ã–π –¥–æ—Ö–æ–¥: $%.2f", incomeAfter), "money")
    elseif incomeChange < 0 then
        log(string.format("   ‚ö†Ô∏è –ü–æ—Ç–µ—Ä—è –¥–æ—Ö–æ–¥–∞: -$%.2f", math.abs(incomeChange)), "warning")
    else
        log("   ‚ûñ –î–æ—Ö–æ–¥ –Ω–µ –∏–∑–º–µ–Ω–∏–ª—Å—è", "info")
    end
    
    -- –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç–∏
    local newTotalSpots = 0
    local newOccupiedSpots = 0
    
    for propertyUID, property in pairs(allProperties) do
        if propertyUID and property then
            newTotalSpots = newTotalSpots + calculateTotalSpots(propertyUID)
            newOccupiedSpots = newOccupiedSpots + calculateOccupiedSpots(propertyUID)
        end
    end
    
    local newPercentageOccupied = newTotalSpots > 0 and (newOccupiedSpots / newTotalSpots * 100) or 0
    
    log(string.format("   üè¢ –ó–∞–ø–æ–ª–Ω–µ–Ω–Ω–æ—Å—Ç—å: %d/%d –º–µ—Å—Ç (%.1f%%)", 
        newOccupiedSpots, newTotalSpots, newPercentageOccupied), "info")
    
    if optimizedCount > 0 then
        log(string.format("   ‚úÖ –£–ª—É—á—à–µ–Ω–æ –æ–±—ä–µ–∫—Ç–æ–≤: %d", optimizedCount), "success")
    else
        log("   üí§ –í—Å–µ –æ–±—ä–µ–∫—Ç—ã —É–∂–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã", "info")
    end
    
    -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
    if newProperties > 0 then
        log(string.format("   üéØ –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤: %d", newProperties), "info")
    end
    
    return optimizedCount, incomeAfter
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –ø–æ—Ä—Ç—Ñ–µ–ª—è
local function setupPortfolioListeners()
    -- –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
    Portfolio.GetUpdateSignal():Connect(function(propertyUID)
        if propertyUID and not propertyCache[propertyUID] then
            log(string.format("üîî –ù–û–í–´–ô –û–ë–™–ï–ö–¢: %s", propertyUID), "info")
            
            -- –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–≥—Ä—É–∑–∫—É –¥–∞–Ω–Ω—ã—Ö
            task.wait(1)
            
            -- –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç
            if isRunning then
                log(string.format("‚ö° –ê–≤—Ç–æ–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞: %s", propertyUID), "spot")
                
                -- –ñ–¥–µ–º –µ—â–µ –Ω–µ–º–Ω–æ–≥–æ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
                task.wait(0.5)
                optimizeProperty(propertyUID)
                
                -- –û–±–Ω–æ–≤–ª—è–µ–º –∫—ç—à
                updatePropertyCache()
            end
        end
    end)
    
    -- –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –Ω–æ–≤—ã–µ –∑–∞—è–≤–∫–∏
    Portfolio.GetApplicantAddedSignal():Connect(function(propertyUID)
        if propertyUID and isRunning and AUTO_ACCEPT_GOOD_APPLICANTS then
            local property = Portfolio.GetAll(propertyUID)
            if property and property.Applicants then
                for applicantId, applicant in pairs(property.Applicants) do
                    if applicantId and applicant then
                        local stars = applicant.Stars or 1
                        if stars >= MIN_STARS then
                            log(string.format("üîî –ù–æ–≤–∞—è —Ö–æ—Ä–æ—à–∞—è –∑–∞—è–≤–∫–∞ –≤ %s: %d‚≠ê", propertyUID, stars), "info")
                            
                            -- –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞
                            if hasAvailableSpots(propertyUID) then
                                task.wait(0.5)
                                local success, message = acceptApplicant(propertyUID, applicantId)
                                if success then
                                    log(string.format("‚úÖ –ê–≤—Ç–æ–ø—Ä–∏–Ω—è—Ç–∏–µ: %s", applicantId), "success")
                                end
                            end
                            break
                        end
                    end
                end
            end
        end
    end)
    
    log("üëÇ –°–ª—É—à–∞—Ç–µ–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω—ã", "success")
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
local function startAutoOptimizer()
    if isRunning then
        log("‚ö†Ô∏è –û–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä —É–∂–µ –∑–∞–ø—É—â–µ–Ω", "warning")
        return
    end
    
    isRunning = true
    log("ü§ñ –ê–í–¢–û–û–ü–¢–ò–ú–ò–ó–ê–¢–û–† –ó–ê–ü–£–©–ï–ù", "success")
    log(string.format("–ù–∞—Å—Ç—Ä–æ–π–∫–∏: –ú–∏–Ω–∏–º—É–º %d‚≠ê | –ò–Ω—Ç–µ—Ä–≤–∞–ª: %d—Å", MIN_STARS, CHECK_INTERVAL), "info")
    
    -- –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞
    updatePropertyCache()
    
    -- –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª
    while isRunning do
        local startTime = tick()
        
        local optimized, totalIncome = optimizeAllProperties()
        
        -- –ï—Å–ª–∏ –±—ã–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è, –æ–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        if optimized > 0 then
            log(string.format("üí∞ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –Ω–æ–≤—ã–π –¥–æ—Ö–æ–¥: $%.2f", totalIncome), "money")
        end
        
        local elapsedTime = tick() - startTime
        local waitTime = math.max(1, CHECK_INTERVAL - elapsedTime)
        
        if isRunning then
            log(string.format("‚è≥ –°–ª–µ–¥—É—é—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ %.1f —Å–µ–∫—É–Ω–¥...", waitTime), "info")
            
            -- –û–∂–∏–¥–∞–Ω–∏–µ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
            for i = 1, math.floor(waitTime) do
                if not isRunning then break end
                task.wait(1)
            end
        end
    end
    
    log("‚èπÔ∏è –ê–í–¢–û–û–ü–¢–ò–ú–ò–ó–ê–¢–û–† –û–°–¢–ê–ù–û–í–õ–ï–ù", "warning")
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–∑–æ–≤–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
local function quickOptimize()
    log("‚ö° –ó–ê–ü–£–°–ö –ë–´–°–¢–†–û–ô –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò", "info")
    updatePropertyCache()
    optimizeAllProperties()
    log("‚úÖ –ë–´–°–¢–†–ê–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø –ó–ê–í–ï–†–®–ï–ù–ê", "success")
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
local function stopOptimizer()
    isRunning = false
    log("üõë –ó–ê–ü–†–û–° –û–°–¢–ê–ù–û–í–ö–ò –û–ü–¢–ò–ú–ò–ó–ê–¢–û–†–ê", "warning")
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç
local function forceFillAllSpots()
    log("üöÄ –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û–ï –ó–ê–ü–û–õ–ù–ï–ù–ò–ï –í–°–ï–• –°–í–û–ë–û–î–ù–´–• –ú–ï–°–¢", "spot")
    
    local allProperties = Portfolio.GetPortfolio()
    local totalFilled = 0
    local totalIncomeGain = 0
    
    for propertyUID, property in pairs(allProperties) do
        if propertyUID and property and property.BuildingType and property.BuildingType ~= "Empty" then
            if hasAvailableSpots(propertyUID) then
                local filled, incomeGain = fillAllAvailableSpots(propertyUID)
                totalFilled = totalFilled + filled
                totalIncomeGain = totalIncomeGain + incomeGain
                task.wait(0.3)
            end
        end
    end
    
    if totalFilled > 0 then
        log(string.format("‚úÖ –ó–∞–ø–æ–ª–Ω–µ–Ω–æ %d —Å–≤–æ–±–æ–¥–Ω—ã—Ö –º–µ—Å—Ç (+$%.2f)", totalFilled, totalIncomeGain), "success")
    else
        log("üí§ –í—Å–µ –º–µ—Å—Ç–∞ —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã", "info")
    end
end

-- –°–æ–∑–¥–∞–Ω–∏–µ GUI –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
local function createControlPanel()
    local PlayerGui = game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui")
    
    -- –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π GUI –µ—Å–ª–∏ –µ—Å—Ç—å
    local oldGUI = PlayerGui:FindFirstChild("RenterOptimizerGUI")
    if oldGUI then oldGUI:Destroy() end
    
    -- –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π GUI
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Name = "RenterOptimizerGUI"
    ScreenGui.Parent = PlayerGui
    
    -- –ì–ª–∞–≤–Ω—ã–π —Ñ—Ä–µ–π–º
    local MainFrame = Instance.new("Frame")
    MainFrame.Size = UDim2.new(0, 380, 0, 400)
    MainFrame.Position = UDim2.new(0.02, 0, 0.5, 0)
    MainFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
    MainFrame.BorderSizePixel = 2
    MainFrame.BorderColor3 = Color3.fromRGB(0, 150, 255)
    MainFrame.Parent = ScreenGui
MainFrame.Active = true
MainFrame.Draggable = true
    
    -- –ó–∞–≥–æ–ª–æ–≤–æ–∫
    local Title = Instance.new("TextLabel")
    Title.Size = UDim2.new(1, 0, 0, 40)
    Title.Position = UDim2.new(0, 0, 0, 0)
    Title.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
    Title.Text = "ü§ñ –ê–í–¢–û–û–ü–¢–ò–ú–ò–ó–ê–¢–û–† 3.1 - –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô"
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.Font = Enum.Font.SourceSansBold
    Title.TextSize = 16
    Title.Parent = MainFrame
    
    -- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä —Ä–∞–±–æ—Ç—ã
    local Indicator = Instance.new("Frame")
    Indicator.Size = UDim2.new(0, 15, 0, 15)
    Indicator.Position = UDim2.new(0.93, 0, 0.04, 0)
    Indicator.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
    Indicator.BorderSizePixel = 2
    Indicator.BorderColor3 = Color3.fromRGB(255, 255, 255)
    Indicator.Name = "StatusIndicator"
    Indicator.Parent = MainFrame
    
    -- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
    local buttonY = 0.12
    local buttonHeight = 0.08
    local buttonSpacing = 0.02
    
    local function createButton(name, text, color, yPos)
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(0.9, 0, buttonHeight, 0)
        button.Position = UDim2.new(0.05, 0, yPos, 0)
        button.Text = text
        button.BackgroundColor3 = color
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Font = Enum.Font.SourceSansBold
        button.TextSize = 14
        button.Name = name
        button.Parent = MainFrame
        return button
    end
    
    -- –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫–∏
    local autoButton = createButton("AutoButton", "‚ñ∂ –ó–ê–ü–£–°–¢–ò–¢–¨ –ê–í–¢–û–û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Æ", 
        Color3.fromRGB(0, 170, 0), buttonY)
    
    local quickButton = createButton("QuickButton", "‚ö° –ë–´–°–¢–†–ê–Ø –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–Ø", 
        Color3.fromRGB(255, 140, 0), buttonY + buttonHeight + buttonSpacing)
    
    local fillButton = createButton("FillButton", "üöÄ –ó–ê–ü–û–õ–ù–ò–¢–¨ –í–°–ï –ú–ï–°–¢–ê", 
        Color3.fromRGB(0, 170, 255), buttonY + (buttonHeight + buttonSpacing) * 2)
    
    local stopButton = createButton("StopButton", "‚èπ –û–°–¢–ê–ù–û–í–ò–¢–¨", 
        Color3.fromRGB(200, 0, 0), buttonY + (buttonHeight + buttonSpacing) * 3)
    
    -- –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    local StatsLabel = Instance.new("TextLabel")
    StatsLabel.Size = UDim2.new(0.9, 0, 0.25, 0)
    StatsLabel.Position = UDim2.new(0.05, 0, 0.65, 0)
    StatsLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
    StatsLabel.Text = "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n–¶–∏–∫–ª: 0\n–û–±—ä–µ–∫—Ç–æ–≤: 0\n–ó–∞–ø–æ–ª–Ω–µ–Ω–æ: 0/0 –º–µ—Å—Ç\n–î–æ—Ö–æ–¥: $0.00"
    StatsLabel.TextColor3 = Color3.fromRGB(220, 220, 255)
    StatsLabel.Font = Enum.Font.SourceSans
    StatsLabel.TextSize = 12
    StatsLabel.TextWrapped = true
    StatsLabel.Name = "StatsLabel"
    StatsLabel.Parent = MainFrame
    
    -- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–Ω–æ–ø–æ–∫
    autoButton.MouseButton1Click:Connect(function()
        if not isRunning then
            task.spawn(function()
                startAutoOptimizer()
            end)
        end
    end)
    
    quickButton.MouseButton1Click:Connect(function()
        task.spawn(function()
            quickOptimize()
        end)
    end)
    
    fillButton.MouseButton1Click:Connect(function()
        task.spawn(function()
            forceFillAllSpots()
        end)
    end)
    
    stopButton.MouseButton1Click:Connect(function()
        stopOptimizer()
    end)
    
    -- –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≤ GUI
    local function updateGUIStats()
        while true do
            task.wait(3)
            
            if MainFrame.Parent then
                local allProperties = Portfolio.GetPortfolio()
                local totalSpots = 0
                local occupiedSpots = 0
                local totalIncome = 0
                local propertyCount = 0
                
                for _, property in pairs(allProperties) do
                    propertyCount = propertyCount + 1
                    totalSpots = totalSpots + calculateTotalSpots(property.UID or "")
                    occupiedSpots = occupiedSpots + calculateOccupiedSpots(property.UID or "")
                    totalIncome = totalIncome + (property.Income or 0)
                end
                
                local percentage = totalSpots > 0 and (occupiedSpots / totalSpots * 100) or 0
                
                StatsLabel.Text = string.format("–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n\n–¶–∏–∫–ª: %d\n–û–±—ä–µ–∫—Ç–æ–≤: %d\n–ó–∞–ø–æ–ª–Ω–µ–Ω–æ: %d/%d –º–µ—Å—Ç (%.1f%%)\n–î–æ—Ö–æ–¥: $%.2f",
                    cycleCount, propertyCount, occupiedSpots, totalSpots, percentage, totalIncome)
                
                -- –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
                if isRunning then
                    Indicator.BackgroundColor3 = Color3.fromRGB(0, 200, 0)
                else
                    Indicator.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
                end
            end
        end
    end
    
    task.spawn(updateGUIStats)
    
    log("üéÆ –ü–∞–Ω–µ–ª—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ–∑–¥–∞–Ω–∞", "success")
    return ScreenGui
end

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
print("\n" .. string.rep("=", 70))
print("üè¢ –ê–í–¢–û–û–ü–¢–ò–ú–ò–ó–ê–¢–û–† –ê–†–ï–ù–î–ê–¢–û–†–û–í –í–ï–†–°–ò–Ø 3.1")
print("üéØ –° –ü–û–õ–ù–´–ú –ó–ê–ü–û–õ–ù–ï–ù–ò–ï–ú –ò –ó–ê–ú–ï–ù–û–ô (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô)")
print(string.rep("=", 70))
print("üìÅ NetworkClient –ø—É—Ç—å:", NetworkPath:GetFullName())
print("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏:")
print("   –ú–∏–Ω–∏–º—É–º –∑–≤–µ–∑–¥: " .. MIN_STARS .. "‚≠ê")
print("   –ò–Ω—Ç–µ—Ä–≤–∞–ª: " .. CHECK_INTERVAL .. "—Å")
print("   –§—É–Ω–∫—Ü–∏–∏: –ê–≤—Ç–æ–ø—Ä–∏–Ω—è—Ç–∏–µ ‚â•4‚≠ê | –ê–≤—Ç–æ–æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ <3‚≠ê")
print("   üîí –ó–∞—â–∏—Ç–∞ –æ—Ç nil –∑–Ω–∞—á–µ–Ω–∏–π –¥–æ–±–∞–≤–ª–µ–Ω–∞")
print(string.rep("=", 70))

-- –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
setupPortfolioListeners()

-- –°–æ–∑–¥–∞–µ–º GUI
createControlPanel()

-- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Å—Ç–∞—Ä—Ç —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
task.wait(3)
log("‚úÖ –°–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞", "success")
log("üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ GUI –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è", "info")
log("üí° –ö–æ–º–∞–Ω–¥—ã –≤ –∫–æ–Ω—Å–æ–ª–∏:", "info")
log("  quickOptimize() - —Ä–∞–∑–æ–≤–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è", "info")
log("  startAutoOptimizer() - –∑–∞–ø—É—Å–∫ –∞–≤—Ç–æ—Ä–µ–∂–∏–º–∞", "info")
log("  stopOptimizer() - –æ—Å—Ç–∞–Ω–æ–≤–∫–∞", "info")
log("  forceFillAllSpots() - –∑–∞–ø–æ–ª–Ω–∏—Ç—å –≤—Å–µ —Å–≤–æ–±–æ–¥–Ω—ã–µ –º–µ—Å—Ç–∞", "info")

-- –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ñ—É–Ω–∫—Ü–∏–∏
_G.quickOptimize = quickOptimize
_G.startAutoOptimizer = startAutoOptimizer
_G.stopOptimizer = stopOptimizer
_G.forceFillAllSpots = forceFillAllSpots
_G.updatePropertyCache = updatePropertyCache

return {
    quickOptimize = quickOptimize,
    startAutoOptimizer = startAutoOptimizer,
    stopOptimizer = stopOptimizer,
    forceFillAllSpots = forceFillAllSpots,
    updatePropertyCache = updatePropertyCache,
    optimizeProperty = optimizeProperty
}
